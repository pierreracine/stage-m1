#!/usr/bin/env python3


#This script takes the .log files and extract various informations , about energies and symmetry. 
#These informtions are written in various files.

#Standart module import :
import sys

#Personal modules import :
import calcul as c
import reading as r
import writting as w

dist_start=float(sys.argv[1])
gap=float(sys.argv[2])
step=int(sys.argv[3])



#Creation of the files containing all data about the computed energies.
#Each line corresponds to a different interatomic distance, written in the first column in Angstrom,
#the second column corresponds to the ground state energy in hartree and the other ones to excited states.

for m in ["s", "t"]:
	with open("energies_data_DFT_"+m,"w") as tofill:
		tofill.write("Distance(A) and energies(H) of the ground state, and "+w.multiplicity(m)[1]+" excited states"+"\n"*2)
for k in range(1,step+1):
	d=c.distance(dist_start, gap, k)
	E0=r.Eelec("scan_DFT_s.log", k)
	for m in ["s", "t"]:
		with open("energies_data_DFT_"+m,"a") as tofill:
			tofill.write(str(d)+"\t"+str(E0)+"\t")
		for state in range(1, 6):
			E=r.root("scan_DFT_"+m+".log", k, state, E0)
			with open("energies_data_DFT_"+m,"a") as tofill:
				tofill.write(str(E)+"\t")
		with open("energies_data_DFT_"+m,"a") as tofill1:
			tofill1.write("\n")


#Edition of two files containing symmetry informations of the states.

for m in ["s", "t"]:
	with open("sym_data_DFT_"+m, "w") as tofill:
		tofill.write("Information about the symmetry of the states"+"\n"*2)
	for state in range(1,6):
		sym=r.ES_symmetry("SP_DFT_"+m+".log", state)
		with open("sym_data_DFT_"+m, "a") as tofill:
			tofill.write(sym+"\n")

#Edition of two file with the informations about optimized interatomic distances and their energies.

for m in ["s", "t"]:
	with open("opt_DFT_"+m,"w") as tofill:
		tofill.write("optimized interatomic distances and energies for the ground state and "+w.multiplicity(m)[1]+"\n"*2)
	d=r.optimized_distance("optGS_DFT.log")
	if d=="not found":
		with open("opt_DFT_"+m,"a") as tofill:
			tofill.write("\n")	
	if d!="not found":
		E0=r.Eelec("optGS_DFT.log", -1)
		with open("opt_DFT_"+m,"a") as tofill:
			tofill.write(d+"\t"+E0+"\n")
	for state in range(1,6):
		d=r.optimized_distance("optES_TD_"+m+str(state)+".log")
		if d=="not found":
			with open("opt_DFT_"+m,"a") as tofill:
				tofill.write("\n")	
		if d!="not found":
			E0=r.Eelec("optES_TD_"+m+str(state)+".log", -1)
			E=r.root("optES_TD_"+m+str(state)+".log", -1, state, E0)
			with open("opt_DFT_"+m,"a") as tofill:
				tofill.write(d+"\t"+str(E)+"\n")


#Script to write a summary of the informations about the excited states.

E0_GS=float(r.Eelec("optGS_DFT.log",-1))
E0_0_GS=float(r.Eelec_ZPE("optGS_DFT.log"))
with open("DFT_ES_summary","w") as tofill:
	tofill.write("Summary of the DFT calculations"
	+"\n"*2+"Transition"+"\t"+"Eadia"+"\t"*2+"Harmonic frequency"+"\t"+"Equilibrium distance"+"\t"+"E0-0"+"\t"*2+"Symmetry of the excited state"
	+"\n"+"\t"*2+"(cm-1)"+"\t"*2+"(cm-1)"+"\t"*3+"(A)"+"\t"*3+"(cm-1)"+"\t"*2+"at S0 geometry"+"\n"*2)
for m in ["s", "t"]:
	for root in range(1, 6):
		E0=r.Eelec("optES_TD_"+m+str(root)+".log",-1)
		E0_0=r.Eelec_ZPE("optES_TD_"+m+str(root)+".log")
		ZPE_ES=r.ZPE("optES_TD_"+m+str(root)+".log")
		if (E0_0=="not found" or E0=="not found" or ZPE_ES=="not found"):
			with open("DFT_ES_summary","a") as tofill:
				tofill.write("\n")
		else:
			dEadia=float(E0_0)-float(ZPE_ES)-E0_GS
			dE0_0=float(E0_0)-E0_0_GS
			d=r.kth_term(r.extract("opt_DFT_"+m,3+root),0)
			f=float(r.freq("optES_TD_"+m+str(root)+".log"))
			if m=="s":
				sym=w.symmetry("sym_data_DFT_"+m, root)
			else:
				sym=w.symmetry("sym_data_DFT_"+m, root-1)
			with open("DFT_ES_summary","a") as tofill:
				tofill.write("S0 --> "+m.upper()+str(root)+"\t"+str(round(dEadia*219472.7,6))+"\t"+str(f)+"\t"*2+d\
				+"\t"*3+str(round(dE0_0*219472.7,6))+"\t"+sym+"\n")
	with open("DFT_ES_summary","a") as tofill:
		tofill.write("\n")
